**Problme No:** 01208
**Problem Id:** 부분 수열의 합 2


처음에는 DP로 풀었고, 다른 풀이가 또 있나를 찾아보다가 투 포인터 풀이로도 풀어보았다(둘 다 무난하게 AC는 받는다).


DP풀이 같은 경우에는 아래와 같이 캐시/점화식을 정의하였다.


- `CACHE[i][s]`: `i`번째 수까지 사용해서 `s`를 만들 수 있는 경우의 수
- `CACHE[i][s]`: `CACHE[i-1][s]` + `CACHE[i-1][s-arr[i]]`


위의 풀이가 가능한 이유는 `s`가 비교적 작은 범위로(40개 수의 최대/최소 범위가 +-40*100000 밖에 되지 않는다.)


아래 사항 정도를 주의해주면 DP로 푸는데 큰 어려움이 없다.


- 정답(경우의 수) 범위가 int를 넘어갈 수 있다.
- 아무것도 고르지 않고 0을 만드는 경우의 수를 빼주어야 한다.


DP풀이의 속도가 조금 맘에 들지 않아서, 다른 풀이를 찾아보았는데 역시 더 좋은 풀이가 있었다.


일단, 주어진 숫자 배열을 2등분한다(좌/우라고 하자).


좌/우에 대해서 각각 나올 수 있는 모든 부분합을 구해서 저장해주자(최대 20개 씩이므로 큰 무리없이 구할 수 있다).


좌/우에 대해서 합 S를 찾는 투 포인터를 돌려주자.


주의할 점은, 처음에 구현을 간단히 하려고 map을 사용했는데, 이렇게하면 TLE가 뜬다.


좌표압축 문제들에서의 교훈과 동일하게, 되도록 flat한 map을 만들도록 하자.
