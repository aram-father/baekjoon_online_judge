**Problme No:** 17071
**Problem Id:** 숨바꼭질 5


크게 어렵지 않게 풀었는데, 풀이까지 이르게 된 사고의 흐름이 나름 기억해둘만해서 조금은 자세히 기록한다.


아래는 풀이와는 무관한 사고의 흐름이다.


>> 처음에 문제를 보고 1차원 DP로 풀 수 있겠거니 생각했다(`CACHE[i]: i에 도착하는 데 걸리는 최소 시간`과 같이).


>> 그런데, 문제를 자세히보니 수빈이는 앞/뒤/점프 이동 모두가 가능해서 최소 시간은 의미가 없을 뿐더러 sub-problem 정의도 어려운 것을 알 수 있었다(CACHE[i]가 CACHE[i-1]을 sub-problem으로 갖는데, CACHE[i-1]은 다시 CACHE[i]를 sub-problem으로 갖음).


>> 따라서, 2차원 DP를 활용해서 풀어보고자 했는데 이 경우에는 문제의 크기가 제한 시간을 만족시키기에는 너무 큰 것을 알 수 있었다(`CACHE[i][s]: s초에 수빈이가 i에 있는 것이 가능한지의 여부`).


>> 자연스럽게 BFS로 방향을 틀어서 생각해보았고, 조금의 응용을 통해 문제를 풀 수 있었다.


문제를 푸는 아이디어는 아래와 같다.


수빈이가 `n`초 후에 `i`에 위치한다면, 자연스럽게 `i+2`, `i+4`, ..., `i+짝수` 초 후에도 `i`에 위치할 수 있다.


따라서, 아래와 같이 visit을 관리하여 BFS를 수행해준다.


- `visit[i][x]: 짝수 초(x==0) 또는 홀수 초(x==1) 후에 i에 도달할 때 가장 빠른 도달 시간`


BFS를 진행하므로 가장 빠른 도달시간을 구하는데에는 큰 어려움이 없다.


`x`초 후에 둘이 `i`에서 만난다는 사실은 `x - visit[i][x % 2] mod 2 == 0` 으로 표현해 줄 수 있다(단, `x` >= `visit[i][x % 2]).
